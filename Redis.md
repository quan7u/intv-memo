> 整理源于小林coding
> https://www.xiaolincoding.com/redis/base/redis_interview.html



## 一、认识Redis

#### 有哪些使用场景？

缓存、分布式锁、消息队列、布隆过滤器等等



#### 与Memcached有什么区别？

相同点：

- 内存数据库（性能高），通常用作缓存
- 过期策略

区别：

- Memcached只有key-value

- Redis有丰富的数据结构，还支持持久化、发布订阅、Lua脚本、哨兵集群模式等等







## 二、数据格式

#### Redis有哪些数据格式？对应什么使用场景？

Redis有五种基础数据类型：

1. String 类型的应用场景:缓存对象、常规计数、分布式锁、共享 session 信息等。

2. List 类型的应用场景:消息队列(但是有两个问题:
   1.生产者需要自行实现全局唯- ID;
   2.不能以消费组形式消费数据)等。

3. Hash 类型:缓存对象、用户信息、购物车等。
4. Set 类型:聚合计算(并集、交集、差集)场景，比如点赞、共同关注、抽奖活动等。
5. Zset 类型:排序场景，比如排行榜、电话和姓名排序等。



Redis 后续版本又支持四种数据类型，它们的应用场景如下

1. BitMap(2.2 版新增):二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等:
2. HyperLogLog(2.8 版新增):海量数据基数统计的场景，比如百万级网页 UV 计数等;
3. GEO(3.2 版新增):存储地理位置信息的场景，比如滴滴叫车;
4. Stream(5.0 版新增):消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性:自动生成全局唯一消息ID，支持以消费组形式消费数据。



#### Zset是如何实现的？

Zset由跳表+哈希表实现，好处是高效支持范围查询和单点查询

在一个Zset内部：

- **哈希表**的作用是存储 **成员（member）到分数（score）的映射**。这样，当我需要执行 ZSCORE myzset member1 这种操作时，就可以利用哈希表的O(1)复杂度，瞬间拿到member1的分数。
- **跳表**的作用是存储 **分数（score）到成员（member）的映射**，并且是**按分数排序的**。跳表本身是一种有序的数据结构，它能支持高效的范围查找。当我需要执行 ZRANGEBYSCORE myzset 10 50 这种操作时，就可以在跳表上快速定位到分数10和50的位置，然后遍历它们之间的元素。

这样一来，通过这两种数据结构的结合，Zset就同时拥有了O(1)的成员查找能力和O(log N)级别的范围查找能力，可以说是两全其美。这是一种典型的**空间换时间**的思想，用额外的存储空间（同时维护哈希表和跳表）来换取了极高的操作效率。



#### 什么是跳表？

![image-20250603000948413](./Redis.assets/image-20250603000948413.png)

> 这个过程就好像我们开车导航，先走高速，再走国道，最后走乡间小路，快速逼近目的地。

查询的时间复杂度为O(logN)



## 三、线程模型

#### Redis是单线程的吗？

通常说的单线程，指的是处理读/写请求的整个过程（**网络IO+命令的执行**）是由一个线程完成的

Redis服务本身不是单线程的，还有三个后台线程

1. 关闭文件
2. AOF 刷盘
3. 释放内存



#### Redis的单线程是如何工作的？

**Reactor 模型** + **epoll（Linux）/ kqueue（Mac）**

Redis 的事件循环 `ae_epoll.c` 注册读/写事件，然后轮询触发。

每次循环处理如下几个阶段：

1. 处理定时任务（如过期 key）
2. 处理网络读事件（接收请求）
3. 处理命令（执行业务逻辑）
4. 处理网络写事件（返回结果）



#### Redis为什么单线程还那么快？

| 原因                 | 说明                                                 |
| -------------------- | ---------------------------------------------------- |
| IO 多路复用（epoll） | 单线程监听所有客户端请求，事件驱动，避免线程切换开销 |
| 操作都是内存级别     | 数据全在内存，读写速度极快，避免了磁盘瓶颈           |
| 高效的数据结构       | 单个 Redis 命令执行时间极短，O(1)/O(logN) 为主       |
| 无锁竞争             | 单线程避免了线程加锁、并发控制，提高执行效率         |



#### Redis 6.0 为什么引入多线程？

Redis 6.0 版本支持的 I/O  多线程特性，默认情况下 I/O 多线程只针对发送响应数据（write client socket），并不会以多线程的方式处理读请求（read client socket）。

要想开启多线程处理客户端读请求，就需要把  Redis.conf  配置文件中的 io-threads-do-reads 配置项设为 yes。





## 四、持久化

#### 如何实现数据不丢失？有哪些方式？

重启/宕机时，内存数据会丢失，所以需要持久化到磁盘

Redis有三种持久化方式：

1. RDB快照：某一时刻的数据，二进制写入磁盘
2. AOF日志：命令追加写到磁盘文件
3. 混合持久化：Redis 4.0 集成上面两种方式



#### RDB是如何实现的？





#### AOF是如何实现的？





#### 哪种更好？为什么需要混合模式？







## 五、集群

#### Redis如何实现高可用？

> 主从、哨兵、分片集群

**哨兵模型**相比主从，增加了哨兵节点，监控主从服务的健康状态，提供自动的故障转移功能

缓存数据量特别大时考虑使用**分片集群**，分散读写压力



#### 为什么是16384？

![img](./Redis.assets/64c703b0c7c1398d9c23d5702dd5e2b8.png)

**1. 配置传播的效率问题（空间占用）**

> 正常的心跳包（heartbeat）会携带每个节点的完整槽位配置，用于节点间更新集群配置。
>  如果使用 16K（16384）个槽，那么每个节点只需要使用 **2KB 的位图（bitmap）空间**来表示这些槽的归属。
>  但如果用了 CRC16 所有的 65536 个值，就需要 **8KB** 的位图，**代价太高**。

a节点的位图

```html
bit[0~4095]   = 1  → 负责这些槽
bit[4096~16383] = 0 → 不负责
```

---



**2. Redis Cluster 不会扩展到超过 1000 个主节点**

> Redis Cluster 的设计并不打算支持超过 1000 个主节点。
>
> 所以分配 16K 个槽足以让每个节点分到 16 个以上的槽，分布粒度合理，也不会造成资源浪费。

------

**3. 16K 是合理的权衡**

- 足够支持数百个节点的数据分布。
- 位图小（2KB）→ 易于在集群之间传播（比如心跳包、配置变更时）。
- 如果太多槽，比如 65K：
  - 配置传播成本大（心跳包传输、存储开销）
  - 变更时广播数据量也大



#### 什么时候moved重定向？什么时候ask？

| 特征         | `MOVED`                    | `ASK`                           |
| ------------ | -------------------------- | ------------------------------- |
| 迁移状态     | 槽已迁移完成               | 槽正在迁移中（尚未完成）        |
| 是否更新映射 | 是（永久更新）             | 否（临时访问）                  |
| 客户端行为   | 重定向后，直接使用目标节点 | 先发送 `ASKING`，再发送请求     |
| 使用场景     | 正常访问到旧节点           | 请求发到了正在接收 key 的新节点 |

> MOVED 是永久搬家，ASK 是临时放行。





## 六、过期与淘汰





## 七、缓存设计

#### 雪崩、击穿、穿透

![图片](./Redis.assets/061e2c04e0ebca3425dd75dd035b6b7b.png)



#### 一致性问题

1、（旁路缓存策略）先更新db，再删除cache：不一致概率低，因为写缓存远快于写db

2、最终一致性：设置较短的过期时间；延迟双删

消息队列重试：引入中间件复杂度

订阅binlog，





## 八、实战问题

#### redis除了缓存，还有什么使用场景？

消息队列（stream）

分布式锁

发布订阅机制（pub/sub）
