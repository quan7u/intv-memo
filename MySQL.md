## 一、基础



## 二、索引

#### 索引有哪些？

基本回答：索引是为了加快数据查询的一种数据结构。

- 从数据结构角度出发，
  -  索引分为B树索引，B+树索引，哈希索引和位图索引。 在MySQL上，主要是采用B+树索引，B树索引在NoSQL上使用较多，哈希索引在KV数据库上较为常见。
- 从形态上来说
  -  可以分成覆盖索引，前缀索引，全文索引，联合索引，唯一索引和主键索引。（下面的定义，可以直接一股脑说出来，也可以等面试官问）
  - 覆盖索引其实是指我们查询的列全部命中了索引；
  - 前缀索引是指只利用了数据前几个字符的索引，如果前面几个字符区分度不好的话，不建议使用前缀索引；
  - 全文索引现在比较少用，一般推荐使用别的中间件来完成，例如ES（小心这一步，可能咔嚓把话题引过去了ES上）；
  - 联合索引是指多个列组成一个索引。创建的时候我们会考虑把区分度好的索引放在前面，因为MySQL遵循最左前缀匹配原则；（这里可能会问你啥是最左前缀匹配原则）
  - 唯一索引是指数据库里面要求该索引值必须要唯一，我们一般用于业务唯一性保证；
  - 主键索引是比较特殊的索引，一般它的叶子节点要么存储了数据，要么存储了指向数据的指针。MySQL的innodb引擎存储的是数据，MyISAM放的是数据的地址；（这里也会引过去聚簇索引与非聚簇索引）
- 从是否存储数据的角度
  -  又可以分为聚簇索引和非聚簇索引，MySQL的主键就是聚簇索引，每张表唯一一个，非聚簇索引的数据本质上存储的是主键。（面试官可能从这里被引导过去聚簇索引与非聚簇索引）

而对于MySQL的innodb来说，它的行锁是利用索引来实现的，所以如果查询的时候没有索引，那么会导致表锁。（这一句可能引导面试官问你锁和事务的问题，如果不熟悉锁和事务，请不要回答）。



#### 什么是最左匹配原则

分析：单单回答最左前缀匹配原则是很简单，但是没有亮点。亮点在，最左前缀匹配大概是如何运作的。之所以只需要回答”大概“如何运作，是因为详细回答太难，面试官没读过源码也搞不清楚，犯不着。

答案：最左前缀匹配原则是指，MySQL会按照联合索引创建的顺序，从左至右开始匹配。例如创建了一个联合索引（A，B，C)，那么本质上来说，是创建了A，（A，B），（A，B，C）三个索引。之所以如此，因为MySQL在使用索引的时候，类似于多重循环，一个列就是一个循环。在这种原则下，我们会优先考虑把区分度最好的放在最左边，而区分度可以简单使用不同值的数量除以总行数来计算（distinct(a, b, c)/count(*)）。



#### 数据库支持哈希索引吗

答案：哈希索引是利用哈希表来实现的，适用于等值查询，如等于，不等于，IN等，对范围查询是不支持的。我们惯常用的innodb引擎是不支持用户自定义哈希索引的，但是innodb有一个优化会建立自适应哈希索引。 所谓的自适应哈希索引，是指innodb引擎，如果发现二级索引（除了主键以外的别的索引）被经常使用，innodb会给这个索引建立一个哈希索引，加快查询。从本质上来说，innodb的自适应哈希索引是一个对索引的哈希索引。



#### 聚簇索引和非聚簇索引的区别

分析：这其实是一个很简单的问题，但也是一个很能装逼的问题。聚簇索引和非聚簇索引的区别，只需要回答，他们叶子节点是否存储了数据。但是要答出亮点，就要多回答两个点：第一，MySQL的非聚簇索引存储了主键；第二，覆盖索引不需要回表。

答案：聚簇索引是指叶子节点存储了数据的索引。MySQL整张表可以看做是一个聚簇索引。 因为非聚簇索引没有存储数据，所以一般是存储了主键。于是会导致一个回表的问题。即如果我们查询的列包含不在索引上的列，这会引起数据库先根据非聚簇索引找出主键，而后拿着主键去聚簇索引里边捞出来数据。而根据主键找数据会引起磁盘IO，性能大幅度下降。这就是我们推荐使用覆盖索引的原因。



#### 什么是延迟关联？todo





#### MySQL为什么使用B+树索引

> 分析：实际上就是为了考察数据结构，B+树的特征，而且能够根据B+树的特征，理解MySQL选择B+树的原因。面试官可能同时希望你能够横向比较B+树、B树、平衡二叉树，红黑树和跳表 直接背这几种树的基本特征是比较难的，所以我们可以只回答关键点。

答案：MySQL使用B+树主要就是考虑三个角度：

1. 和二叉树，如平衡二叉树，红黑树比起来，B+树是多叉树，比如MySQL默认是1200叉树，同样数据量，高度要比二叉树低；
2. 和B树比起来，B+树的叶子节点被连接起来，形成了一个链表，这意味着，当我们执行范围查询的时候，MySQL可以利用这个特性，沿着叶子节点前进。而之所以NoSQL数据库会使用B树作为索引，也是因为它们不像关系型数据库那般大量查询都是范围查询；
3. B+树只在叶子节点存放数据，因此和B树比起来，查询时间稳定可预测。（注：这是一个高级观点，就是在工程实践中，我们可能倾向于追求一种稳定可预测，而不是某些数据贼快，某些数据唰一下贼慢） B+树非叶子节点能存储更多的索引指针，同样的数据量下树的高度会更矮
4. B+树和跳表比起来，MySQL将B+树节点大小设置为磁盘页大小，这样可以充分利用MySQL的预加载机制，**减少磁盘IO**

关键点：高度低，叶子节点是链表，查询时间可预测性，节点大小等于页大小

聊到了范围查询或者全表扫描，你可以从B+树的角度来说，这种扫描利用到了B+树叶子节点是链表的特征；



#### 为什么使用自增主键

分析：这是一个常考点，从根源上来说，是为了考察你对数据库如何组织数据的理解。问题在于，数据库如何组织数据其实是一个很难的问题，所以一般情况下，不需要回答到非常底层的地步。

答案：MySQL的主键是一个**聚簇索引**，即它的叶子节点存放了数据。 在使用自增主键的情况下，会保证树的分裂照着单方向分裂的，这会大概率导致物理页的分裂也是朝着单方向进行的，即连续的。 在不使用自增主键的情况下，如果在已经满的页里面插入，会导致MySQL页分裂，虽然逻辑上页依旧是连续的，但是物理页已经不连续了。 如果在使用机械硬盘的情况下，会导致范围查询经常导致机械硬盘重新定位，性能差。

关键点：单方向增长，物理页连续，**防止页分裂**



#### 什么是索引下推

分析：这个题更加无聊，因为它对于你的实际工作帮助可以说没有了。前面那些点理解清楚，还可以说有助于自己设计索引，这个就可以说，完全没用。回答这个问题的关键点在于，要和联合索引、覆盖索引一起讨论。因为他们体现的都是一个东西：即尽量利用索引数据，避免回表。

答案：索引下推是指将于索引有关的条件由MySQL服务器下推到引擎。例如按照名字存取姓张的，like "张%"。在原来没有索引下推的时候，即便在用户名字上建立了索引，但是还是不能利用这个索引。而在支持**索引下推的引擎上**，引擎就可以利用名字索引，将数据提前过滤，避免回表。目前innodb引擎和MyISAM都支持索引下推。索引下推和覆盖索引的理念都是一致的，尽量避免回表。

#### 使用索引了为什么还是很慢？（todo 区分度）

分析：这又是属于违背直觉的问题，本质上考察的是你对索引，和MySQL执行过程的理解。记住一个核心点，**索引只能帮你快速定位到数据**，而定位到数据之后的事情，比如说把读数据，比如说写数据，这都是要时间的。尤其是要考虑事务机制，锁竞争的问题。

答案：索引只能帮助定位数据，但是**从索引定位到数据，到返回结果，或者更新数据，都需要时间**。尤其是在事务中，索引定位到数据之后，可能一直在等待锁。如果别的事务执行时间缓慢，那么即便你用了索引，这一次的查询还是很慢。本质上是因为，MySQL 的执行速度是受到很多因素影响的，准确来说，索引只是大概率能够加速这个过程而已。

另外要考虑，数据库是否使用错了索引。如果我们的表上面创建了多个索引，那么就会导致 MySQL 选择使用了不那么恰当的索引。在这种时候，我们可以通过数据库的 Hint 机制提示数据库走某个索引。

关键字：锁竞争

#### 什么时候索引会失效？

分析：索引失效这个说法有点误导人，准确的说法是，为什么我明明定义了索引，但是MySQL却没有使用索引？关键点是权衡，即下面的第二个理由。

答案：没有使用索引主要有两大类原因，一种是自己 SQL 没写好，例如：

1. 索引列上做了计算
2. like 关键字用了前缀匹配，例如”%abc“。注意的是，后缀匹配是可以用索引；
3. 字符串没有引号导致类型转换

另一种，则是 MySQL 判断到使用索引的代价很高，比如说要全索引扫描并且回表，那么就会退化成为全表扫描。数据库数据量的大小和数据分布，会影响MySQL的决策。

#### 单表两亿瓶颈了吗？

[为什么大家说mysql数据库单表最大两千万？依据是啥？](https://mp.weixin.qq.com/s/XX_NkIIf_PLyU4IE6lEEYQ)

https://www.v2ex.com/t/887224

https://www.v2ex.com/t/882773

单表即可，深分页采用联表子查询 [深分页](https://bjpaws9mtg.feishu.cn/wiki/VZVEwPAzyi3CKgkLjdecRZgOnWf) 

#### 索引有什么缺点

答案：索引的维护是有开销的。在增改数据的时候，数据库都要对应修改索引； 而如果索引过多，以至于内存没法装下全部索引，那么会导致访问索引本身都会触发IO。所以索引不是越多越好。 比如为了避免数据量过大，某些时候我们会使用前缀索引。



## 三、事务

#### 能够解释一下MySQL的隔离级别吗？

分析：考察基本的知识点。如果只是背出来各种隔离级别和对应存在的问题，那么就达标了。刷亮点如何刷呢？一个是结合 MVCC 来阐述MySQL是如何支持的；一个是讨论 snapshot isolation。

数据库的隔离级别有四种：

1. 未提交读：事务可以读取另外一个事务没有提交的数据。 问题：脏读，不可重复读，幻读
2. 提交读：事务只能读取到另外一个已经提交的事务数据。 问题： 不可重复度，幻读
3. 重复读：事务执行过程查询结果都是一致的，innodb 默认级别。 问题： 幻读
4. 串行化：读写都会相互阻塞 问题：

MVCC 方向： innodb 引擎利用了 Read View 来支持提交读和重复读。

提交读这个级别，默认读取是不加锁的，只有修改才会加锁。简单来说，已提交读，是每次查询都生成一个新的Read View，所以永远都能看到已经提交的事务。

可重复读则是在第一次查询生成Read View之后，后面的查询都是使用这个Read View。

snapshot isolation 方向：

innodb 引擎的可重复读隔离级别，要比定义的隔离级别更加严苛一点。一般的可重复读，无法解决幻读的问题。比如说原本你事务里面查询订单信息，这个时候又插入了一个新的订单，那么这种时候，幻读就会导致我们下一个查询就会查询到这条记录。但是 innodb 引擎的隔离级别并不会出现这个问题。

因为 innodb 引擎使用了next-key lock，在“当前读”，也就是写的时候，锁住了记录之间的空档，防止插入数据。（这里面，不需要解释临键锁，等面试官提问）



## 四、锁



#### 死锁

[死锁案例](https://bjpaws9mtg.feishu.cn/wiki/XZZVwxXcnirdJwkZGrVc8hPYnHe) 

[20 | 幻读是什么，幻读有什么问题？-极客时间](https://time.geekbang.org/column/article/75173)

[21 | 为什么我只改一行的语句，锁这么多？-极客时间](https://time.geekbang.org/column/article/75659)

[30 | 答疑文章（二）：用动态的观点看加锁-极客时间](https://time.geekbang.org/column/article/78427)





#### 参考资料

[美团技术-innodb中的事务隔离级别和锁的关系](https://tech.meituan.com/2014/08/20/innodb-lock.html)

[美团技术-MySQL索引原理及慢查询优化](https://tech.meituan.com/2014/06/30/mysql-index.html)

[一文理解MySQL MVCC](https://zhuanlan.zhihu.com/p/29150809)

[MySQL 有哪些锁？| 小林coding](https://xiaolincoding.com/mysql/lock/mysql_lock.html)